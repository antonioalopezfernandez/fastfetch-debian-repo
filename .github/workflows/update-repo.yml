# Nombre descriptivo del workflow
name: Actualizar Repositorio de Debian (inmutable + firmado + changelog)

on:
  # Permite ejecutarlo manualmente desde la interfaz de GitHub Actions
  workflow_dispatch:
  # Se ejecuta automáticamente todos los días a las 02:00 UTC
  schedule:
    - cron: "0 2 * * *"

# Evita ejecuciones concurrentes del mismo workflow
concurrency:
  group: apt-repo-fastfetch
  cancel-in-progress: false

jobs:
  build-and-publish:
    # Se ejecuta en Ubuntu
    runs-on: ubuntu-latest

    # Permiso mínimo necesario para publicar en gh-pages
    permissions:
      contents: write

    env:
      # Opcional: filtra arquitecturas (por nombre del .deb). Deja vacío para todas.
      # Ejemplo: "amd64|arm64"
      APT_ARCH_FILTER: ""

    steps:
      # 1. Descarga el código fuente del repo
      - name: Checkout repositorio
        uses: actions/checkout@v4

      # 2. Instala herramientas necesarias para empaquetar y firmar
      - name: Instalar herramientas necesarias
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y \
            dpkg-dev apt-utils gnupg fakeroot xz-utils jq curl
          # dpkg-dev/apt-utils → generar Packages y Release
          # gnupg → firmar con GPG
          # fakeroot → reempaquetar .deb
          # jq/curl → parsear JSON y descargar

      # 3. Descarga la última release de Fastfetch desde GitHub y sus .deb
      - name: Descargar la última release de Fastfetch (API GitHub)
        id: get_release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          API_URL="https://api.github.com/repos/fastfetch-cli/fastfetch/releases/latest"

          # Descarga JSON de la última release
          curl -sS -H "Authorization: Bearer $GH_TOKEN" \
               -H "Accept: application/vnd.github+json" \
               -H "User-Agent: gh-actions-fastfetch" \
               -o /tmp/release.json "$API_URL"

          # Extrae el tag (ej: v2.51.1)
          LAST_VERSION=$(jq -r '.tag_name' /tmp/release.json)
          if [[ -z "${LAST_VERSION}" || "${LAST_VERSION}" == "null" ]]; then
            echo "No se pudo obtener el tag de la última release"; exit 1
          fi
          echo "Última versión: $LAST_VERSION"
          echo "LAST_VERSION=$LAST_VERSION" >> "$GITHUB_ENV"

          # Limpia residuos previos y prepara carpeta
          mkdir -p "repo/v${LAST_VERSION}"
          rm -f repo/*.deb || true

          # Extrae URLs de assets .deb (filtrando por arquitectura si se define)
          if [[ -n "$APT_ARCH_FILTER" ]]; then
            jq -r --arg re "$APT_ARCH_FILTER" \
              '.assets[] | select(.browser_download_url | endswith(".deb")) | select(.name | test($re)) | .browser_download_url' \
              /tmp/release.json > /tmp/deb_urls.txt
          else
            jq -r '.assets[].browser_download_url | select(endswith(".deb"))' \
              /tmp/release.json > /tmp/deb_urls.txt
          fi

          # Si no hay .deb, falla
          if [[ ! -s /tmp/deb_urls.txt ]]; then
            echo "No hay assets .deb en la release $LAST_VERSION (filtro: '${APT_ARCH_FILTER}')" ; exit 1
          fi

          # Descarga cada .deb
          while IFS= read -r url; do
            echo "Descargando $(basename "$url")"
            curl -fL -o "repo/$(basename "$url")" "$url"
          done < /tmp/deb_urls.txt

      # 4. Inyecta el changelog dentro de cada .deb (para apt-listchanges)
      - name: Inyectar changelog en los .deb (desde CHANGELOG.md)
        shell: bash
        run: |
          set -euo pipefail
          # Intenta bajar el CHANGELOG.md del tag correspondiente; si no, master; si no, main
          curl -fsSL "https://raw.githubusercontent.com/fastfetch-cli/fastfetch/${LAST_VERSION}/CHANGELOG.md" -o /tmp/CHANGELOG.md \
            || curl -fsSL "https://raw.githubusercontent.com/fastfetch-cli/fastfetch/master/CHANGELOG.md" -o /tmp/CHANGELOG.md \
            || curl -fsSL "https://raw.githubusercontent.com/fastfetch-cli/fastfetch/main/CHANGELOG.md" -o /tmp/CHANGELOG.md

          # Extrae solo la sección de la versión actual
          ver="${LAST_VERSION#v}"
          awk -v ver="$ver" '
            BEGIN{printit=0}
            /^[[:space:]]*#{1,6}[[:space:]]/ {
              if (printit) exit
              line=$0
              gsub(/[][]/,"", line)
              if (line ~ ("[[:space:]]v?" ver "([[:space:]]|$|\\))")) { printit=1; print; next }
            }
            { if (printit) print }
          ' /tmp/CHANGELOG.md > /tmp/CHANGELOG_SECTION.md || true

          # Si no se encontró la sección específica, usa todo el changelog
          if [[ ! -s /tmp/CHANGELOG_SECTION.md ]]; then
            echo "Aviso: no se encontró sección específica de $ver; se usará todo el CHANGELOG."
            cp /tmp/CHANGELOG.md /tmp/CHANGELOG_SECTION.md
          fi

          # Inyecta changelog en cada .deb
          shopt -s nullglob
          for deb in repo/*.deb; do
            workdir="$(mktemp -d)"
            fakeroot dpkg-deb -R "$deb" "$workdir"
            PKG_NAME=$(awk -F': *' '$1=="Package"{print $2; exit}' "$workdir/DEBIAN/control")

            # Crea el changelog comprimido
            DOCDIR="$workdir/usr/share/doc/$PKG_NAME"
            mkdir -p "$DOCDIR"
            gzip -9c /tmp/CHANGELOG_SECTION.md > "$DOCDIR/changelog.Debian.gz"
            cp "$DOCDIR/changelog.Debian.gz" "$DOCDIR/changelog.gz"
            cp "$DOCDIR/changelog.Debian.gz" "$DOCDIR/NEWS.Debian.gz"

            # Regenera md5sums
            ( cd "$workdir"
              find . -type f ! -path './DEBIAN/*' -printf '%P\n' \
                | LC_ALL=C sort \
                | xargs -r md5sum > DEBIAN/md5sums )

            # Reempaqueta con nombre inmutable (-repo1)
            NEW_DEB="${deb}.new"
            fakeroot dpkg-deb -b "$workdir" "$NEW_DEB"
            DEB_VER=$(dpkg-deb -f "$NEW_DEB" Version)
            DEB_ARCH=$(dpkg-deb -f "$NEW_DEB" Architecture)
            FINAL_NAME="${PKG_NAME}_${DEB_VER}-repo1_${DEB_ARCH}.deb"
            mkdir -p "repo/v${LAST_VERSION}"
            mv "$NEW_DEB" "repo/v${LAST_VERSION}/$FINAL_NAME"

            rm -f "$deb"
            rm -rf "$workdir"
          done
          shopt -u nullglob

      # 5. Importa la clave GPG privada para firmar el Release
      - name: Importar clave GPG
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
        shell: bash
        run: |
          set -euo pipefail
          if [[ -z "${GPG_PRIVATE_KEY:-}" ]]; then
            echo "Falta el secreto GPG_PRIVATE_KEY"; exit 1
          fi
          mkdir -p ~/.gnupg
          chmod 700 ~/.gnupg
          echo "pinentry-mode loopback" >> ~/.gnupg/gpg.conf
          echo "$GPG_PRIVATE_KEY" | gpg --batch --import
          KEY_FP=$(gpg --list-secret-keys --with-colons | awk -F: '/^sec:/ {print $5; exit}')
          if [[ -z "${KEY_FP}" ]]; then
            echo "No se pudo importar/encontrar la clave GPG"; exit 1
          fi
          echo "KEY_FP=$KEY_FP" >> "$GITHUB_ENV"

      # 6. Genera índices del repo y los firma con GPG
      - name: Crear índices y firmar
        env:
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        shell: bash
        run: |
          set -euo pipefail
          if [[ -z "${GPG_PASSPHRASE:-}" ]]; then
            echo "Falta el secreto GPG_PASSPHRASE"; exit 1
          fi

          cd repo

          # Genera Packages y Packages.gz
          dpkg-scanpackages -m "v${LAST_VERSION}" /dev/null > Packages
          gzip -9f -c Packages > Packages.gz

          # Genera apt.conf con metadatos descriptivos
          printf '%s\n' \
            'APT::FTPArchive::Release {' \
            '  Origin "fastfetch (community mirror)";' \
            '  Label "fastfetch";' \
            '  Suite "stable";' \
            '  Codename "fastfetch";' \
            '};' > apt.conf

          # Genera el archivo Release
          apt-ftparchive -c=apt.conf release . > Release

          # Firma Release → Release.gpg e InRelease
          gpg --batch --yes --pinentry-mode loopback \
              --passphrase "$GPG_PASSPHRASE" \
              -abs -o Release.gpg Release
          gpg --batch --yes --pinentry-mode loopback \
              --passphrase "$GPG_PASSPHRASE" \
              --clearsign -o InRelease Release

          # Exporta la clave pública (ASCII armor)
          gpg --armor --export "$KEY_FP" > public.gpg

          # Evita que GitHub Pages toque nada
          : > .nojekyll

      # 7. Verificación: todos los Filename en Packages existen
      - name: Sanity check - Packages vs ficheros
        shell: bash
        run: |
          set -euo pipefail
          cd repo
          awk '/^Filename: /{print $2}' Packages > /tmp/files.txt
          while IFS= read -r f; do
            if [[ ! -f "$f" ]]; then
              echo "ERROR: falta $f"
              exit 1
            fi
          done < /tmp/files.txt

      # 8. Publica la carpeta repo/ en la rama gh-pages (GitHub Pages)
      - name: Publicar en GitHub Pages
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./repo
          publish_branch: gh-pages
          commit_message: "Actualizar a Fastfetch ${{ env.LAST_VERSION }} (inmutable, firmado, changelog)"
