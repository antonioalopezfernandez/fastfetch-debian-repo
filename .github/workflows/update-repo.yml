# Nombre descriptivo del workflow
name: Actualizar Repositorio de Debian (inmutable + firmado + changelog)

on:
  workflow_dispatch:
  schedule:
    - cron: "0 2 * * *" # 02:00 UTC

concurrency:
  group: apt-repo-fastfetch
  cancel-in-progress: false

jobs:
  build-and-publish:
    runs-on: ubuntu-latest

    permissions:
      contents: write  # publicar en gh-pages

    defaults:
      run:
        shell: bash
    env:
      GPG_TTY: /dev/tty

    steps:
      # 1. Código fuente (necesario para publicar en gh-pages)
      - name: Checkout repositorio
        uses: actions/checkout@v4

      # 2. Herramientas necesarias para empaquetar y firmar
      - name: Instalar herramientas necesarias
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y \
            dpkg-dev apt-utils gnupg fakeroot xz-utils jq curl coreutils

      # 3. Última release de Fastfetch (API GitHub) y descarga de .deb
      - name: Descargar la última release de Fastfetch (API GitHub)
        id: get_release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          API_URL="https://api.github.com/repos/fastfetch-cli/fastfetch/releases/latest"

          curl -sS -H "Authorization: Bearer $GH_TOKEN" \
               -H "Accept: application/vnd.github+json" \
               -H "User-Agent: gh-actions-fastfetch" \
               -o /tmp/release.json "$API_URL"

          LAST_VERSION=$(jq -r '.tag_name' /tmp/release.json)
          test -n "$LAST_VERSION"
          echo "LAST_VERSION=$LAST_VERSION" >> $GITHUB_ENV

          # URLs .deb
          jq -r '.assets[].browser_download_url | select(endswith(".deb"))' \
            /tmp/release.json > /tmp/deb_urls.txt

          if [[ ! -s /tmp/deb_urls.txt ]]; then
            echo "No se encontraron assets .deb en $LAST_VERSION"; exit 1
          fi

          rm -rf repo
          mkdir -p "repo/${LAST_VERSION}"

          # Descarga .deb a una carpeta temporal
          mkdir -p /tmp/debs
          while IFS= read -r url; do
            fname="$(basename "$url")"
            echo "Descargando $fname"
            curl -fL --retry 3 -o "/tmp/debs/$fname" "$url"
          done < /tmp/deb_urls.txt

      # 4. Inyectar changelog en los .deb (para apt-listchanges)
      - name: Inyectar changelog en los .deb (desde CHANGELOG.md)
        run: |
          set -euo pipefail
          curl -fsSL "https://raw.githubusercontent.com/fastfetch-cli/fastfetch/${LAST_VERSION}/CHANGELOG.md" -o /tmp/CHANGELOG.md \
            || curl -fsSL "https://raw.githubusercontent.com/fastfetch-cli/fastfetch/main/CHANGELOG.md" -o /tmp/CHANGELOG.md

          ver="${LAST_VERSION#v}"
          awk -v ver="$ver" '
            BEGIN{printit=0}
            /^##[[:space:]]/ {
              if ($0 ~ ver) { printit=1; print; next }
              if (printit) { exit }
            }
            { if (printit) print }
          ' /tmp/CHANGELOG.md > /tmp/CHANGELOG_SECTION.md || true

          if [[ ! -s /tmp/CHANGELOG_SECTION.md ]]; then
            echo "Aviso: no se encontró sección específica de $ver; se usará todo el CHANGELOG."
            cp /tmp/CHANGELOG.md /tmp/CHANGELOG_SECTION.md
          fi

          shopt -s nullglob
          for deb in /tmp/debs/*.deb; do
            workdir="$(mktemp -d)"
            fakeroot dpkg-deb -R "$deb" "$workdir"

            PKG_NAME=$(awk -F': *' '$1=="Package"{print $2; exit}' "$workdir/DEBIAN/control")
            DOCDIR="$workdir/usr/share/doc/$PKG_NAME"
            mkdir -p "$DOCDIR"

            gzip -9c /tmp/CHANGELOG_SECTION.md > "$DOCDIR/changelog.Debian.gz"
            cp "$DOCDIR/changelog.Debian.gz" "$DOCDIR/changelog.gz"
            cp "$DOCDIR/changelog.Debian.gz" "$DOCDIR/NEWS.Debian.gz"

            # Regenerar md5sums
            ( cd "$workdir"
              find . -type f ! -path './DEBIAN/*' -printf '%P\n' \
                | LC_ALL=C sort \
                | xargs -r md5sum > DEBIAN/md5sums )

            NEW_DEB="${deb}.new"
            fakeroot dpkg-deb -b "$workdir" "$NEW_DEB"

            DEB_VER=$(dpkg-deb -f "$NEW_DEB" Version)
            DEB_ARCH=$(dpkg-deb -f "$NEW_DEB" Architecture)
            FINAL_NAME="${PKG_NAME}_${DEB_VER}-repo1_${DEB_ARCH}.deb"
            mv "$NEW_DEB" "repo/${LAST_VERSION}/$FINAL_NAME"

            rm -rf "$workdir"
          done
          shopt -u nullglob

      # 5. Importar clave GPG para firmar el Release
      - name: Importar clave GPG
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          mkdir -p ~/.gnupg
          chmod 700 ~/.gnupg
          echo "pinentry-mode loopback" >> ~/.gnupg/gpg.conf

          echo "$GPG_PRIVATE_KEY" | gpg --batch --import
          KEY_FP=$(gpg --list-secret-keys --with-colons | awk -F: '/^sec:/ {print $5; exit}')
          test -n "$KEY_FP"
          echo "KEY_FP=$KEY_FP" >> $GITHUB_ENV

      # 6. Generar índices del repo y firmarlos
      - name: Crear índices y firmar
        env:
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          set -euo pipefail
          cd repo
          # Solo indexamos la carpeta de esta versión (inmutabilidad)
          dpkg-scanpackages -m "${LAST_VERSION}" /dev/null > Packages
          gzip -9f -c Packages > Packages.gz

          apt-ftparchive release . > Release

          # Firmas: Release.gpg y InRelease
          gpg --batch --yes --pinentry-mode loopback \
              --passphrase "$GPG_PASSPHRASE" \
              -abs -o Release.gpg Release

          gpg --batch --yes --pinentry-mode loopback \
              --passphrase "$GPG_PASSPHRASE" \
              --clearsign -o InRelease Release

          # Exportar la clave pública
          gpg --armor --export "$KEY_FP" > public.gpg

          # Evitar .nojekyll mangling
          echo > .nojekyll

      # 7. Sanity check: los Filename de Packages existen
      - name: Sanity check - Packages vs ficheros
        run: |
          set -euo pipefail
          cd repo
          awk '/^Filename: /{print $2}' Packages > /tmp/files.txt
          while IFS= read -r f; do
            [[ -f "$f" ]] || { echo "ERROR: falta $f"; exit 1; }
          done < /tmp/files.txt

      # 8. Publicar en GitHub Pages
      - name: Publicar en GitHub Pages
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./repo
          publish_branch: gh-pages
          commit_message: "Actualizar a Fastfetch ${{ env.LAST_VERSION }} (inmutable, firmado, changelog)"