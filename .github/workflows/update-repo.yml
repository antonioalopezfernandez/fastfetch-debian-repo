# Nombre descriptivo del workflow
name: Actualizar Repositorio de Debian (inmutable + firmado + changelog)

on:
  # Permite ejecutarlo manualmente desde la interfaz de GitHub Actions
  workflow_dispatch:
  # Se ejecuta automáticamente todos los días a las 02:00 UTC
  schedule:
    - cron: "0 2 * * *"

concurrency:
  group: apt-repo-fastfetch
  cancel-in-progress: false

jobs:
  build-and-publish:
    # El job se ejecuta en una máquina virtual con Ubuntu
    runs-on: ubuntu-latest

    # Solo necesita permiso para publicar en gh-pages
    permissions:
      contents: write

    steps:
      # 1. Descarga el código fuente de este repo (necesario para publicar en gh-pages)
      - name: Checkout repositorio
        uses: actions/checkout@v4

      # 2. Instala las herramientas necesarias para empaquetar y firmar
      - name: Instalar herramientas necesarias
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y \
            dpkg-dev apt-utils gnupg fakeroot xz-utils jq curl
          # dpkg-dev/apt-utils → generar Packages y Release
          # gnupg → firmar con GPG
          # fakeroot → reempaquetar .deb
          # jq/curl → parsear JSON y descargar

      # 3. Obtiene la última release de Fastfetch desde la API de GitHub y descarga los .deb
      - name: Descargar la última release de Fastfetch (API GitHub)
        id: get_release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          API_URL="https://api.github.com/repos/fastfetch-cli/fastfetch/releases/latest"

          # Descarga JSON de la última release
          curl -sS -H "Authorization: Bearer $GH_TOKEN" \
               -H "Accept: application/vnd.github+json" \
               -H "User-Agent: gh-actions-fastfetch" \
               -o /tmp/release.json "$API_URL"

          # Extrae el tag (ej: v2.51.1)
          LAST_VERSION=$(jq -r '.tag_name' /tmp/release.json)
          echo "LAST_VERSION=$LAST_VERSION" >> $GITHUB_ENV

          # Crea carpeta para los .deb
          mkdir -p "repo/v${LAST_VERSION}"

          # Extrae todas las URLs de assets que terminen en .deb
          jq -r '.assets[].browser_download_url | select(endswith(".deb"))' /tmp/release.json > /tmp/deb_urls.txt

          # Descarga cada .deb
          while IFS= read -r url; do
            curl -fL -o "repo/$(basename "$url")" "$url"
          done < /tmp/deb_urls.txt

      # 4. Inyecta el changelog dentro de cada .deb (para apt-listchanges)
      - name: Inyectar changelog en los .deb (desde CHANGELOG.md)
        run: |
          set -euo pipefail
          # Intenta bajar el CHANGELOG.md del tag correspondiente
          # Si no existe, usa la rama master (no main)
          curl -fsSL "https://raw.githubusercontent.com/fastfetch-cli/fastfetch/${LAST_VERSION}/CHANGELOG.md" -o /tmp/CHANGELOG.md \
            || curl -fsSL "https://raw.githubusercontent.com/fastfetch-cli/fastfetch/master/CHANGELOG.md" -o /tmp/CHANGELOG.md

          # Extrae solo la sección de la versión actual
          ver="${LAST_VERSION#v}"
          awk -v ver="$ver" '
            BEGIN{printit=0}
            /^[[:space:]]*#{1,6}[[:space:]]/ {
              if (printit) exit
              line=$0
              gsub(/[][]/,"", line)
              if (line ~ ("[[:space:]]v?" ver "([[:space:]]|$|\\))")) { printit=1; print; next }
            }
            { if (printit) print }
          ' /tmp/CHANGELOG.md > /tmp/CHANGELOG_SECTION.md || true

          # Si no se encontró la sección, usa todo el changelog para no quedar vacío
          if [[ ! -s /tmp/CHANGELOG_SECTION.md ]]; then
            echo "Aviso: no se encontró sección específica de $ver; se usará todo el CHANGELOG."
            cp /tmp/CHANGELOG.md /tmp/CHANGELOG_SECTION.md
          fi

          mkdir -p "repo/v${LAST_VERSION}"
          shopt -s nullglob
          for deb in repo/*.deb; do
            workdir="$(mktemp -d)"
            # Desempaqueta el .deb
            fakeroot dpkg-deb -R "$deb" "$workdir"
            PKG_NAME=$(awk -F': *' '$1=="Package"{print $2; exit}' "$workdir/DEBIAN/control")

            # Crea el changelog comprimido
            DOCDIR="$workdir/usr/share/doc/$PKG_NAME"
            mkdir -p "$DOCDIR"
            gzip -9c /tmp/CHANGELOG_SECTION.md > "$DOCDIR/changelog.Debian.gz"
            cp "$DOCDIR/changelog.Debian.gz" "$DOCDIR/changelog.gz"
            cp "$DOCDIR/changelog.Debian.gz" "$DOCDIR/NEWS.Debian.gz"

            # Regenera md5sums
            ( cd "$workdir"
              find . -type f ! -path './DEBIAN/*' -printf '%P\n' \
                | LC_ALL=C sort \
                | xargs -r md5sum > DEBIAN/md5sums )

            # Reempaqueta con nombre inmutable (evita colisiones)
            NEW_DEB="${deb}.new"
            fakeroot dpkg-deb -b "$workdir" "$NEW_DEB"
            DEB_VER=$(dpkg-deb -f "$NEW_DEB" Version)
            DEB_ARCH=$(dpkg-deb -f "$NEW_DEB" Architecture)
            FINAL_NAME="${PKG_NAME}_${DEB_VER}-repo1_${DEB_ARCH}.deb"
            mv "$NEW_DEB" "repo/v${LAST_VERSION}/$FINAL_NAME"

            rm -f "$deb"
            rm -rf "$workdir"
          done
          shopt -u nullglob

      # 5. Importa la clave GPG para firmar el Release
      - name: Importar clave GPG
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          mkdir -p ~/.gnupg
          chmod 700 ~/.gnupg
          echo "pinentry-mode loopback" >> ~/.gnupg/gpg.conf
          echo "$GPG_PRIVATE_KEY" | gpg --batch --import
          KEY_FP=$(gpg --list-secret-keys --with-colons | awk -F: '/^sec:/ {print $5; exit}')
          echo "KEY_FP=$KEY_FP" >> $GITHUB_ENV

      # 6. Genera índices del repo y los firma
      - name: Crear índices y firmar
        env:
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          set -euo pipefail
          cd repo
          dpkg-scanpackages -m "v${LAST_VERSION}" /dev/null > Packages
          gzip -9f -c Packages > Packages.gz
          apt-ftparchive release . > Release

          # Firma Release → Release.gpg e InRelease
          gpg --batch --yes --pinentry-mode loopback \
              --passphrase "$GPG_PASSPHRASE" \
              -abs -o Release.gpg Release
          gpg --batch --yes --pinentry-mode loopback \
              --passphrase "$GPG_PASSPHRASE" \
              --clearsign -o InRelease Release

          # Exporta la clave pública
          gpg --armor --export "$KEY_FP" > public.gpg

          # Evita que GitHub Pages modifique nada
          echo > .nojekyll

      # 7. Verificación: todos los Filename en Packages existen
      - name: Sanity check - Packages vs ficheros
        run: |
          set -euo pipefail
          cd repo
          awk '/^Filename: /{print $2}' Packages > /tmp/files.txt
          while IFS= read -r f; do
            if [ ! -f "$f" ]; then
              echo "ERROR: falta $f"
              exit 1
            fi
          done < /tmp/files.txt

      # 8. Publica la carpeta repo/ en la rama gh-pages (GitHub Pages)
      - name: Publicar en GitHub Pages
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./repo
          publish_branch: gh-pages
          commit_message: "Actualizar a Fastfetch ${{ env.LAST_VERSION }} (inmutable, firmado, changelog)"
