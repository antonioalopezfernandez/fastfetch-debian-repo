name: Actualizar Repositorio de Debian (firmado + changelog)

on:
  workflow_dispatch:
  schedule:
    - cron: "0 2 * * *" # Todos los días a las 02:00 UTC

jobs:
  build-and-publish:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repositorio
        uses: actions/checkout@v3

      - name: Instalar herramientas necesarias
        run: |
          sudo apt-get update
          # dpkg-dev: dpkg-scanpackages | apt-utils: apt-ftparchive | gnupg: gpg | fakeroot: reempaquetar
          sudo apt-get install -y dpkg-dev apt-utils jq curl gnupg fakeroot

      - name: Descargar la última release de Fastfetch (API GitHub)
        id: get_release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          API_URL="https://api.github.com/repos/fastfetch-cli/fastfetch/releases/latest"

          # Llamada autenticada para evitar rate limits y guardar JSON
          HTTP_CODE=$(curl -sS -H "Authorization: Bearer $GH_TOKEN" \
                              -H "Accept: application/vnd.github+json" \
                              -H "User-Agent: gh-actions-fastfetch" \
                              -w "%{http_code}" -o /tmp/release.json "$API_URL")

          if [ "$HTTP_CODE" != "200" ]; then
            echo "Fallo al pedir la API (HTTP $HTTP_CODE):"
            cat /tmp/release.json || true
            exit 1
          fi

          LAST_VERSION=$(jq -r '.tag_name // empty' /tmp/release.json)
          if [ -z "${LAST_VERSION:-}" ]; then
            echo "La respuesta no contiene tag_name:"
            cat /tmp/release.json
            exit 1
          fi
          echo "Se encontró la versión más reciente: $LAST_VERSION"
          echo "LAST_VERSION=$LAST_VERSION" >> $GITHUB_ENV

          mkdir -p repo

          # Filtra URLs de los .deb oficiales publicados por Fastfetch
          jq -r '.assets[].browser_download_url
                 | select(test("fastfetch-linux-(amd64|aarch64|armv6l|armv7l)\\.deb$"))' \
                 /tmp/release.json > /tmp/deb_urls.txt

          if [ ! -s /tmp/deb_urls.txt ]; then
            echo "No se encontraron .deb en la release $LAST_VERSION"
            exit 1
          fi

          # Descarga cada .deb a ./repo
          while IFS= read -r url; do
            echo "Descargando $(basename "$url") ..."
            if ! curl -fL -o "repo/$(basename "$url")" "$url"; then
              echo "ADVERTENCIA: fallo al descargar $url"
              rm -f "repo/$(basename "$url")" || true
            fi
          done < /tmp/deb_urls.txt

          echo "Contenido inicial de repo/:"
          ls -l repo || true

      - name: Inyectar changelog en los .deb
        run: |
          set -euo pipefail

          # Usa el cuerpo de la release como changelog
          jq -r '.body // "Upstream release ${LAST_VERSION}"' /tmp/release.json > /tmp/RELEASE_BODY.txt

          shopt -s nullglob
          for deb in repo/*.deb; do
            echo "Procesando $deb"
            workdir="$(mktemp -d)"
            # Desempaqueta
            fakeroot dpkg-deb -R "$deb" "$workdir"

            # Asegura carpeta de documentación
            mkdir -p "$workdir/usr/share/doc/fastfetch"

            # Genera changelog y alias Debian
            CHANGELOG="$workdir/usr/share/doc/fastfetch/changelog"
            sed 's/\r$//' /tmp/RELEASE_BODY.txt > "$CHANGELOG"
            printf "\n-- fastfetch %s\n" "${LAST_VERSION}" >> "$CHANGELOG"
            gzip -9f "$CHANGELOG"
            ln -sf changelog.gz "$workdir/usr/share/doc/fastfetch/changelog.Debian.gz"
            chmod 644 "$workdir/usr/share/doc/fastfetch/"*.gz || true

            # Reempaqueta y reemplaza
            fakeroot dpkg-deb -b "$workdir" "${deb}.new"
            mv -f "${deb}.new" "$deb"
            rm -rf "$workdir"
          done
          shopt -u nullglob

          echo "Contenido de repo/ tras inyección de changelog:"
          ls -l repo || true

      - name: Importar clave GPG (para firmar Release)
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          echo "$GPG_PRIVATE_KEY" | gpg --batch --import
          # Evita prompt interactivo
          mkdir -p ~/.gnupg
          echo "pinentry-mode loopback" >> ~/.gnupg/gpg.conf
          chmod 600 ~/.gnupg/gpg.conf
          # Fingerprint de la clave importada
          KEY_FP=$(gpg --list-secret-keys --with-colons | awk -F: '/^sec:/ {print $5; exit}')
          if [ -z "${KEY_FP:-}" ]; then
            echo "No se encontró clave GPG importada."
            exit 1
          fi
          echo "KEY_FP=$KEY_FP" >> $GITHUB_ENV

      - name: Crear índices y firmar el repositorio
        env:
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          set -euo pipefail
          cd repo

          # Genera BOTH 'Packages' y 'Packages.gz' (APT a veces busca el no comprimido)
          dpkg-scanpackages -m . /dev/null > Packages
          gzip -9f Packages > Packages.gz

          # Genera Release leyendo lo que hay en el directorio
          apt-ftparchive release . > Release

          # Firma separada (Release.gpg)
          gpg --batch --yes --pinentry-mode loopback \
              --passphrase "$GPG_PASSPHRASE" \
              -abs -o Release.gpg Release

          # Firma inline (InRelease)
          gpg --batch --yes --pinentry-mode loopback \
              --passphrase "$GPG_PASSPHRASE" \
              --clearsign -o InRelease Release

          # Exporta la clave pública para clientes APT
          gpg --armor --export "$KEY_FP" > public.gpg

          echo "Archivos generados:"
          ls -l

      - name: Publicar en GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./repo
          publish_branch: gh-pages
          commit_message: "Actualizar a Fastfetch ${{ env.LAST_VERSION }} (firmado y con changelog)"