name: Actualizar Repositorio de Debian (firmado + changelog + robusto)

on:
  workflow_dispatch:
  schedule:
    - cron: "0 2 * * *" # Todos los días a las 02:00 UTC

jobs:
  build-and-publish:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repositorio
        uses: actions/checkout@v3

      - name: Instalar herramientas necesarias
        run: |
          sudo apt-get update
          # dpkg-dev: dpkg-scanpackages | apt-utils: apt-ftparchive | gnupg: gpg | fakeroot: reempaquetar | xz-utils por si acaso
          sudo apt-get install -y dpkg-dev apt-utils jq curl gnupg fakeroot xz-utils

      - name: Descargar la última release de Fastfetch (API GitHub)
        id: get_release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          API_URL="https://api.github.com/repos/fastfetch-cli/fastfetch/releases/latest"

          HTTP_CODE=$(curl -sS -H "Authorization: Bearer $GH_TOKEN" \
                              -H "Accept: application/vnd.github+json" \
                              -H "User-Agent: gh-actions-fastfetch" \
                              -w "%{http_code}" -o /tmp/release.json "$API_URL")

          if [ "$HTTP_CODE" != "200" ]; then
            echo "Fallo al pedir la API (HTTP $HTTP_CODE):"
            cat /tmp/release.json || true
            exit 1
          fi

          LAST_VERSION=$(jq -r '.tag_name // empty' /tmp/release.json)
          if [ -z "${LAST_VERSION:-}" ]; then
            echo "La respuesta no contiene tag_name:"
            cat /tmp/release.json
            exit 1
          fi
          echo "Se encontró la versión más reciente: $LAST_VERSION"
          echo "LAST_VERSION=$LAST_VERSION" >> $GITHUB_ENV

          mkdir -p repo

          # Tomamos TODAS las URLs de assets que terminen en .deb
          jq -r '.assets[].browser_download_url | select(endswith(".deb"))' /tmp/release.json > /tmp/deb_urls.txt

          if [ ! -s /tmp/deb_urls.txt ]; then
            echo "No se encontraron assets .deb en la release $LAST_VERSION"
            exit 1
          fi

          # Descarga
          ok=0
          while IFS= read -r url; do
            file="repo/$(basename "$url")"
            echo "Descargando $(basename "$url") ..."
            if curl -fL -o "$file" "$url"; then
              ok=$((ok+1))
            else
              echo "ADVERTENCIA: fallo al descargar $url"
              rm -f "$file" || true
            fi
          done < /tmp/deb_urls.txt

          echo "Se descargaron $ok archivos .deb"
          if [ "$ok" -eq 0 ]; then
            echo "ERROR: No se descargó ningún .deb. Abortando para evitar un Packages vacío/inexistente."
            exit 1
          fi

          echo "Contenido inicial de repo/:"
          ls -l repo || true

      - name: Inyectar changelog en los .deb
        run: |
          set -euo pipefail

          # Usa el cuerpo de la release como changelog
          jq -r '.body // "Upstream release ${LAST_VERSION}"' /tmp/release.json > /tmp/RELEASE_BODY.txt

          shopt -s nullglob
          for deb in repo/*.deb; do
            echo "Procesando $deb"
            workdir="$(mktemp -d)"
            # Desempaqueta
            fakeroot dpkg-deb -R "$deb" "$workdir"

            # Asegura carpeta de documentación
            mkdir -p "$workdir/usr/share/doc/fastfetch"

            # Genera changelog y alias Debian
            CHANGELOG="$workdir/usr/share/doc/fastfetch/changelog"
            sed 's/\r$//' /tmp/RELEASE_BODY.txt > "$CHANGELOG"
            printf "\n-- fastfetch %s\n" "${LAST_VERSION}" >> "$CHANGELOG"
            gzip -9f "$CHANGELOG"
            ln -sf changelog.gz "$workdir/usr/share/doc/fastfetch/changelog.Debian.gz"
            chmod 644 "$workdir/usr/share/doc/fastfetch/"*.gz || true

            # Reempaqueta y reemplaza
            fakeroot dpkg-deb -b "$workdir" "${deb}.new"
            mv -f "${deb}.new" "$deb"
            rm -rf "$workdir"
          done
          shopt -u nullglob

          echo "Contenido de repo/ tras inyección de changelog:"
          ls -l repo || true

      - name: Importar clave GPG (para firmar Release)
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          echo "$GPG_PRIVATE_KEY" | gpg --batch --import
          # Evita prompt interactivo
          mkdir -p ~/.gnupg
          echo "pinentry-mode loopback" >> ~/.gnupg/gpg.conf
          chmod 600 ~/.gnupg/gpg.conf
          # Fingerprint de la clave importada
          KEY_FP=$(gpg --list-secret-keys --with-colons | awk -F: '/^sec:/ {print $5; exit}')
          if [ -z "${KEY_FP:-}" ]; then
            echo "No se encontró clave GPG importada."
            exit 1
          fi
          echo "KEY_FP=$KEY_FP" >> $GITHUB_ENV

      - name: Crear índices y firmar el repositorio
        env:
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          set -euo pipefail
          cd repo

          # Verificación previa: debe haber al menos un .deb
          count=$(ls -1 *.deb 2>/dev/null | wc -l | tr -d ' ')
          if [ "$count" -eq 0 ]; then
            echo "ERROR: No hay .deb en repo/. No se pueden generar índices."
            exit 1
          fi

          # Genera BOTH 'Packages' y 'Packages.gz'
          echo "Generando Packages y Packages.gz..."
          if ! dpkg-scanpackages -m . /dev/null > Packages; then
            echo "ERROR: dpkg-scanpackages falló."
            exit 1
          fi
          if [ ! -s Packages ]; then
            echo "ERROR: 'Packages' está vacío. ¿Los .deb son válidos?"
            ls -l
            exit 1
          fi
          gzip -9f -c Packages > Packages.gz

          # Genera Release (incluye checksums de los ficheros presentes)
          apt-ftparchive release . > Release

          # Firmas
          gpg --batch --yes --pinentry-mode loopback \
              --passphrase "$GPG_PASSPHRASE" \
              -abs -o Release.gpg Release

          gpg --batch --yes --pinentry-mode loopback \
              --passphrase "$GPG_PASSPHRASE" \
              --clearsign -o InRelease Release

          # Exporta la clave pública para clientes APT
          gpg --armor --export "$KEY_FP" > public.gpg

          # Asegura que GitHub Pages no procese nada
          echo > .nojekyll

          echo "Listado final de repo/:"
          ls -l

      - name: Publicar en GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./repo
          publish_branch: gh-pages
          commit_message: "Actualizar a Fastfetch ${{ env.LAST_VERSION }} (firmado, changelog, índices verificados)"